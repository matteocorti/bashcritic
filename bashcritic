#!/usr/bin/perl

# RCS information (required by Perl::Critic)
# enable substitution with:
#   $ svn propset svn:keywords "Id Revision HeadURL Source Date"
#
#   $Id$
#   $Revision$
#   $HeadURL$
#   $Date$

use 5.008;
use strict;
use warnings;
use Carp;

use version; our $VERSION = '0.2.0';

use Data::Dumper;
use File::Slurp;
use English qw(-no_match_vars);
use Getopt::Long;
use Pod::Usage qw(pod2usage);
use List::Util qw(first);

##############################################################################
# Configuration

Getopt::Long::Configure( 'bundling', 'ignorecase', );

##############################################################################
# Global vars

# Hash of hashes containing the checks to be perfomed
# - name        : name of the check
# - *           : anonymous hash with
#   - severity    : the severity level of the check
#   - shells      : list of shells where this applies
#   - function    : the subrouting implementing the test
#   - description : a short description
my %checks;

# command line options
my $bourne        = 0;
my $color         = 1;
my $getopt_result;
my $help;
my $list_format;
my $posix         = 1;
my $severity      = 5;
my $verbosity     = 0;

my @shells = (
    'POSIX'
);

# constants

# severity levels
my $GENTLE = 5;
my $STERN  = 4;
my $HARSH  = 3;
my $CRUEL  = 2;
my $BRUTAL = 1;

# according to sysexits on FreeBSD (should check if there is a CPAN module with exit codes
my $EXIT_USAGE       = 64;
my $EXIT_UNAVAILABLE = 69;

my $NAME_PATTERN = '[A-Za-z0-9_]+';

##############################################################################
# Subroutines

##############################################################################
# Usage     : verbose("some message string", $optional_verbosity_level);
# Purpose   : write a message if the verbosity level is high enough
# Returns   : n/a
# Arguments : message : message string
#             level   : options verbosity level
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub verbose {

    # arguments
    my $message = shift;
    my $level   = shift;

    if ( !defined $level ) {
        $level = 0;
    }

    if ( $level < $verbosity ) {
        print $message;
    }

    return;

}

##############################################################################
# Usage     : perform_checks($filename)
# Purpose   : performs all the registered checks on the given filename
# Returns   : n/a
# Arguments : file : name of the file to check
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub perform_checks {
    my $file = shift;
    verbose "checking $file\n";
    for my $name (keys %checks) {
        if (${$checks{$name}}{severity} >= $severity) {        
            verbose '> checking rule: '
                . ${$checks{$name}}{description}
                    . "\n", 1;
            &{${$checks{$name}}{function}}( $file, read_file($file) );
        }
    }
    return;
}

##############################################################################
# Usage     : list_checks() or list_checks($format)
# Purpose   : list all the configured checks
# Returns   : n/a
# Arguments : $format (optional) a special formatting
#             - trac
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub list_checks {
    
    my $format = shift;
    
    if (defined $format &&
            !grep { /$format/} ( 'trac')) {
        pod2usage(
            -message => "unknown list formatting '$format'",
            -exitval => $EXIT_USAGE,
        );
    }

    if ($format eq 'trac') {
        for my $name (keys %checks) {

            # || description || severity || shells ||
            
            print '||'
                . ${$checks{$name}}{description}
                . '||'
                . "${$checks{$name}}{severity}"
                . '||'
                . "$checks{$name}{shells}||\n";
            
        }
    }
    else {
        for my $name (keys %checks) {

            # description (severity level) [ shells ]
            
            print ${$checks{$name}}{description}
                . " (severity ${$checks{$name}}{severity}) ["
                . $checks{$name}{shells}
                . "]\n";
        }
    }
    
    return;
}

##############################################################################
# Usage     : colorize_checks()
# Purpose   : colorizes the checks according to severity
# Returns   : n/a
# Arguments : n/a
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub colorize_checks {
    for my $key (keys %checks) {
        if ($checks{$key}{severity} == $GENTLE) {
            $checks{$key}{description} =
                Term::ANSIColor::colored( $checks{$key}{description}, 'bold red' );
        }
        if ($checks{$key}{severity} == $STERN) {
            $checks{$key}{description} =
                Term::ANSIColor::colored( $checks{$key}{description}, 'yellow' );
        }
    }
    return;
}

##############################################################################
# Usage     : check_pattern($filename, $pattern, $message, @lines)
# Purpose   : searches for the given pattern in the lines array and prints a
#             message if found
# Returns   : n/a
# Arguments : $file    : name of the file to check
#             $pattern : the pattern to look for
#             $message : the warning message ('LINE_NUMBER' will be
#                        substituted with the current line number)
#             @lines   : array of lines of the given file
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub check_pattern {

    my ($file, $pattern, $message, @lines) = @_;

    my $counter = 0;

    for my $line (@lines) {
        $counter++;
        if ( $line =~ /$pattern/mx ) {
            my $error = $message;
            $error =~ s/LINE_NUMBER/$counter/mx;
            print "$error\n";
        }
    }

    return;

}

##############################################################################
# Usage     : initialize_checks()
# Purpose   : initializes the checks hash
# Returns   : n/a
# Arguments : n/a
# Throws    : n/a
# Comments  : n/a
# See also  : n/a
sub initialize_checks() {

    # fill in names severities and descriptions first (functions
    # will be inserted later so that they can use these fields in the
    # definition

    ####################
    # portability checks
    #
    # checks from rules described by
    # http://www.bash-hackers.org/wiki/doku.php?id=scripting:nonportable
    
    # SOURCE
    $checks{SOURCE} = {
        severity    => $STERN,
        shells      => ( 'POSIX' ),
        description => '"source FILE" is not portable use ". FILE" instead.',
    };
    $checks{SOURCE}{function} = sub {
        my $file = shift;
        check_pattern(
            $file,
            'source\ ',
            "Severity $checks{SOURCE}{severity} at $file:LINE_NUMBER: "
                . $checks{SOURCE}{description},
            @_,
        );
        return;
    };

    # DECLARE
    $checks{DECLARE} = {
        severity    => $STERN,
        shells      => ( 'POSIX' ),
        description => '"declare keyword" is not portable use subshells (...) or $(...) to define'
            . ' local variables (or variables with special attributes).',
    };
    $checks{DECLARE}{function} = sub {
        my $file = shift;
        check_pattern(
            $file,
            'declare\ ',
            "Severity $checks{DECLARE}{severity} at $file:LINE_NUMBER: "
                . $checks{DECLARE}{description},
            @_,
        );
        return;
    };

    # DECLARE
    $checks{DECLARE} = {
        severity    => $STERN,
        shells      => ( 'POSIX' ),
        description => '"typeset keyword" is not portable use subshells (...) or $(...) to define'
            . ' local variables (or variables with special attributes).',
    };
    $checks{DECLARE}{function} = sub {
        my $file = shift;
        check_pattern(
            $file,
            'typeset\ ',
            "Severity $checks{DECLARE}{severity} at $file:LINE_NUMBER: "
                . $checks{DECLARE}{description},
            @_,
        );
        return;
    };

    # HERE_STRING
    $checks{HERE_STRING} = {
        severity    => $STERN,
        shells      => ( 'POSIX' ),
        description => 'Avoid here-strings (a special form of the here-document)'
            . ' in portable scripts.',
    };
    $checks{HERE_STRING}{function} = sub {
        my $file = shift;
        check_pattern(
            $file,
            '<<<',
            "Severity $checks{HERE_STRING}{severity} at $file:LINE_NUMBER: "
                . $checks{HERE_STRING}{description},
            @_,
        );
        return;
    };

    # EXPORT_ASSIGN
    $checks{EXPORT_ASSIGN} = {
        severity    => $STERN,
        shells      => ( 'BOURNE' ),
        description => q{Though POSIX allows it, bourne shell don't want the assignment}
            . ' and the exporting in one command.',
    };
    $checks{EXPORT_ASSIGN}{function} = sub {
        my $file = shift;
        check_pattern(
            $file,
            'export\ .*=',
            "Severity $checks{EXPORT_ASSIGN}{severity} at $file:LINE_NUMBER: "
                . $checks{EXPORT_ASSIGN}{description},
            @_,
        );
        return;
    };

    # ARITH_COMPOUND
    $checks{ARITH_COMPOUND} = {
        severity    => $STERN,
        shells      => ( 'POSIX' ),
        description => q{POSIX does't define an arithmetic compund command, many shells}
            . q{don't know it. Using the pseudo-command : and the arithmetic expansion}
                . q{ $(( )) is a kind of workaround here.},
    };
    $checks{ARITH_COMPOUND}{function} = sub  {
        my $file = shift;
        check_pattern(
            $file,
            '^[^:]*\(\(.*\)\)',
            "Severity $checks{ARITH_COMPOUND}{severity} at $file:LINE_NUMBER: "
                . $checks{ARITH_COMPOUND}{description},
            @_,
        );
        return;
    };

    # BASHISH_TEST
    $checks{BASHISH_TEST} = {
        severity    => $STERN,
        shells      => ( 'POSIX' ),
        description => q{The Bashish test keyword "[[" is reserved by POSIX, }
            . q{but not defined. Use the old fashioned way with the test command}
                . q{ ("test" or "[").},
    };
    $checks{BASHISH_TEST}{function} = sub {
        my $file = shift;
        check_pattern(
            $file,
            '\[\[\ .*\ \]\]',
            "Severity $checks{BASHISH_TEST}{severity} at $file:LINE_NUMBER: "
                . $checks{BASHISH_TEST}{description},
            @_,
        );
        return;
    };


    #####################
    # obsolete constructs
    #
    # http://www.bash-hackers.org/wiki/doku.php?id=scripting:obsolete

    # CSHELL_REDIR
    $checks{CSHELL_REDIR} = {
        severity    => $STERN,
        shells      => ( 'POSIX' ),
        description => q{The &>FILE >&FILE redirection syntax is short for >FILE 2>&1}
            . q{ and is derived from the C-Shell. It's very old and not part of POSIX.},
    };
    $checks{CSHELL_REDIR}{function} = sub {
        my $file = shift;
        check_pattern(
            $file,
            '[^0-9]((&>)|(>&))',
            "Severity $checks{CSHELL_REDIR}{severity} at $file:LINE_NUMBER: "
                . $checks{CSHELL_REDIR}{description},
            @_,
        );
        return;
    };

    # DOLLAR_BRACKET
    $checks{DOLLAR_BRACKET} = {
        severity    => $STERN,
        shells      => ( 'POSIX' ),
        description => q{The $[EXPRESSION] syntax is completely replaced by the }
            . q{POSIX-conform arithmetic expansion $((EXPRESSION)).},
    };
    $checks{DOLLAR_BRACKET}{function} = sub {
        my $file = shift;
        check_pattern(
            $file,
            '\$\[.*\]',
            "Severity $checks{DOLLAR_BRACKET}{severity} at $file:LINE_NUMBER: "
                . $checks{DOLLAR_BRACKET}{description},
            @_,
        );
        return;
    };

    # BACKTICKS
    $checks{BACKTICKS} = {
        severity    => $HARSH,
        shells      => ( 'POSIX' ),
        description => q{`COMMANDS` is an older form of the command substitution. }
            . q{The usage of the POSIX-form $(COMMANDS) is preferred.} ,
    };
    $checks{BACKTICKS}{function} = sub {
        my $file = shift;
        check_pattern(
            $file,
            '\`.*\`',
            "Severity $checks{BACKTICKS}{severity} at $file:LINE_NUMBER: "
                . $checks{BACKTICKS}{description},
            @_,
        );
        return;
    };

    # FUNCTION
    $checks{FUNCTION} = {
        severity    => $STERN,
        shells      => ( 'POSIX' ),
        description => q{The "function NAME { ...; }" form of the function definition}
            . q{ is not recommended simply use NAME() { ...; } to define a function.},
    };
    $checks{FUNCTION}{function} = sub {
        my $file = shift;
        check_pattern(
            $file,
            'function\ *' . $NAME_PATTERN . '\ *{',
            "Severity $checks{FUNCTION}{severity} at $file:LINE_NUMBER: "
                . $checks{FUNCTION}{description},
            @_,
        );
        return;
    };

    # LET
    $checks{LET} = {
        severity    => $HARSH,
        shells      => ( 'POSIX' ),
        description => q{"let MATH" is the classic form of the arithmetic evaluation }
            . q{command. Bash has an own compound command for that, which should be used}
                . q{ if possible: ": $((MATH))".} ,
    };
    $checks{LET}{function} = sub {
        my $file = shift;
        check_pattern(
            $file,
            'let\ ',
            "Severity $checks{LET}{severity} at $file:LINE_NUMBER: "
                . $checks{LET}{description},,
            @_,
        );
        return;
    };


    ############
    # Formatting

    # LONG_LINES
    $checks{LONG_LINES} = {
        severity    => $CRUEL,
        shells      => ( 'POSIX' ),
        description => 'Line is longer than 78 characters, consider splitting it over'
            . " multiple lines to increase readability.",
    };
    $checks{LONG_LINES}{function} = sub {
        my $file    = shift;
        my @lines   = read_file($file);
        my $counter = 0;
        for my $line (@lines) {
            $counter++;
            if ( length $line > 78 ) {
                print "Severity $checks{LONG_LINES}{severity} at $file:$counter: "
                    . $checks{LONG_LINES}{description}
                        . "\n";
            }
        }
        return;
    };

    return;

}

##############################################################################
# Main

initialize_checks();

############################
# Parse command line options

Getopt::Long::Configure(
    'bundling',
    'no_ignore_case'
);

$getopt_result = GetOptions(

    # severity levels
    '1|brutal'      => sub { $severity = 1; },
    '2|cruel'       => sub { $severity = 2; },
    '3|harsh'       => sub { $severity = 3; },
    '4|stern'       => sub { $severity = 4; },
    '5|gentle'      => sub { $severity = 5; },
    'severity'      => \$severity,

    'list|l:s'      => \$list_format,            # optional string
    
    'color|colour!' => \$color,                  # can be negated

    # shells
    'bourne!'       => \$bourne,
    'posix!'        => \$posix,
    
    'help|h|?'      => \$help,
    'verbose|v+'    => \$verbosity,
    'version|V'     => sub { print "bashcritic version $VERSION\n"; exit 0; },
    
) or pod2usage();

if (defined $list_format) {
    list_checks($list_format);
    exit 0;
}

##############################
# Parse command line arguments

my @FILES = ();

if ( !@ARGV || ( @ARGV == 1 && $ARGV[0] eq q{-} ) ) {

    # Reading code from STDIN.  All the code is slurped into
    # a string.  PPI will barf if the string is just whitespace.
    my $code_string = do { local $RS = undef; <STDIN> };

    # Notice if STDIN was closed (pipe error, etc)
    if ( !defined $code_string ) {
        $code_string = q{};
    }

    $code_string =~ m{ \S+ }mx || confess qq{Nothing to critique.\n};
    @FILES = \$code_string;    #Convert to SCALAR ref for PPI
}
else {

    # Test to make sure all the specified files or directories
    # actually exist.  If any one of them is bogus, then die.
    if ( my $nonexistant = first { !-e $_ } @ARGV ) {
        my $msg = qq{No such file or directory: '$nonexistant'};
        pod2usage( -exitstatus => 1, -message => $msg, -verbose => 0 );
    }

    @FILES = @ARGV;
}

##############################################################################
# Sanity checks

# check if Term::ANSIColors is available

eval { require Term::ANSIColor; };
if ($@ && $color) {
    print "warning 'Term::ANSIColor' is not available: cannot colorize output\n";
    $color = 0;
}

if ($color) {
    require Term::ANSIColor;
    colorize_checks();
}

################
# process shells
if ($posix)  { push @shells, 'POSIX';  }
if ($bourne) { push @shells, 'BOURNE'; }

##############################################################################
# check the files

for my $file (@FILES) {
    perform_checks($file);
}

1;

__END__

=pod

=head1 NAME

C<bashcritic> - critiques shell scripts

=head1 SYNOPSIS

  bashcritic [-12345 | --brutal | --cruel | --harsh | --stern | --gentle]
             [--posix | --bourne]
             [--severity number | name]
             [--list [format]]
             [-verbose ]
             {FILE | STDIN}

  options:

  [ TODO ]

  possible listing formats
  - trac    for the trac twiki

=head1 DESCRIPTION

critiques shell scripts

=head1 VERSION

Version 1.0.0

=head1 REQUIRED ARGUMENTS

none

=head1 OPTIONS

TODO

=head1 USAGE EXAMPLES

bashcritic -gentle file_to_analyze

=head1 DIAGNOSTICS

=head1 EXIT STATUS

1 on error, 0 otherwise

=head1 DEPENDENCIES

bashcritic depends on

=over 4

=item * Carp;

=item * version;

=item * English

=item * Getopt::Long

=back

=head1 CONFIGURATION

=head1 INCOMPATIBILITIES

None reported.

=head1 SEE ALSO

=head1 BUGS AND LIMITATIONS

No bugs have been reported.

Please report any bugs or feature requests to matteo.corti@id.ethz.ch,
or through the web interface at
https://trac.id.ethz.ch/projects/bashcritic

=head1 AUTHOR

Matteo Corti <matteo.corti@id.ethz.ch>

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2007, ETH Zurich.

This module is free software; you can redistribute it and/or modify it
under the terms of GNU general public license (gpl) version 3.
See the LICENSE file for details.

=head1 DISCLAIMER OF WARRANTY

BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT
WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
PARTIES PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND,
EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

=head1 ACKNOWLEDGMENTS

